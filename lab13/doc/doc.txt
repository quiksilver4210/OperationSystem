В queue.c имеются 2 проблемы:

1. Разные потоки могут обращатсья к next_in, next_out и array одновременно.
Поэтому может возникнуть ситуация, когда,
например, в одну и ту же ячейку массива запись произойдет дважды,
при этом функция инкремента также вызовется дважды.
Тогда возникнет ситуация, в которой одна из ячеек массива будет пропущена,
что является некорректной работой программы.

2. Если мы хотим удалить элемент из пустой очереди,
то программа завершится с ошибкой. Корректно работающая программа должна
ждать до тех пор, пока в очереди не появится элемент и после этого его удалить.
Аналогично с полной очередью.

Сделаем 3 теста:
Первый тест будет проверять первую проблему
Для этого мы заполним элементы очереди нулями.
Далее в двух потоках будем добавлять в очередь число 1.
В наивной реализации программа будет выдан ассерт,
в остальных первый тест будет пройден.

Второй тест проверяет удаление из пустой очереди.
Для этого в одном потоке делаем поп, а в другом усыпляем программу на секнду и только потом делаем пуш.
Этим мы гарантируем, что функция добавления в очередь вызовется позже, чем функция удаления.
Третий тест проверяет добавление в полную очередь. В одном из потоков добавим в очередь на 1 элемент больше, чем можно.
Во втором усыпим программу на секунду и после сделаем поп. Т.е. гарантируем,
что удаление из очереди вызовется позже, чем добавление всех элементов.

В queue.c и queue-mutex.c программа упадет, в реализации с использованием условных
переменных проблем не возникает.